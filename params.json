{"name":"StreamAlg","tagline":"Streams à la carte: Extensible stream pipelines with object algebras.","body":"## StreamAlg\r\n\r\n[![Build Status](https://travis-ci.org/biboudis/streamalg.svg?branch=master)](https://travis-ci.org/biboudis/streamalg)\r\n\r\nThe StreamAlg repository contains the source code artifact that accompanies the\r\n[_Streams à la carte: Extensible Pipelines with Object Algebras_](http://goo.gl/P2XO68) paper, to appear at the\r\n[29th European Conference on Object-Oriented Programming (ECOOP'15)](http://2015.ecoop.org/).\r\n\r\n### Overview\r\n\r\nWe address extensibility shortcomings in libraries for lazy-streaming queries\r\nwith a new design. The architecture underlying this design borrows heavily from\r\nOliveira and Cook's object algebra solution to the expression problem, extended\r\nwith a design that exposes the push/pull character of the iteration, and an\r\nencoding of higher-kinded polymorphism.\r\n\r\nIn this library we apply our design to Java and show that the addition of full\r\nextensibility is accompanied by high performance, matching or exceeding that of\r\nthe original, highly-optimized Java streams library.\r\n\r\nIn this repository we present a fundamental set of sequential operators ```map```,\r\n```filter```, ```reduce```, ```count```, ```take/limit``` and ```iterate```.\r\n\r\nAdditionally we present the behaviors that are discussed in the paper: push, pull, fused pull, logging, id (for\r\nblocking terminal operators), future (for non-blocking terminal operators).\r\n\r\n### Getting Started\r\n\r\n#### Prerequisites\r\nThe project runs with Java 8.\r\n\r\n#### Testing\r\nClone the project:\r\n```shell\r\ngit clone git@github.com:biboudis/streamalg.git\r\n```\r\nThe project is built with maven and its dependencies are automatically resolved: Guava, JMH and JUnit. To run the test suite simply run:\r\n```shell\r\nmvn test\r\n```\r\nThe tests cover all examples included in the paper (operators, behaviors) and cases used as motivation as well. The ```streams``` package is covered at:\t87% classes,\t90% methods,\t91% lines.\r\n\r\n#### Running Benchmarks\r\nBenchmarks are reproduced by executing:\r\n```shell\r\nsh run_benchmarks.sh\r\n```\r\n\r\n### Project Structure\r\nThe basic packages of this artifact are the following:\r\n\r\n#### Object Algebras\r\n- StreamAlg: describes the object algebra of the intermediate operators of streams.\r\n- TakeStreamAlg: adds to streams the ```take``` combinator.\r\n- ExecStreamAlg: adds to streams the terminal operators.\r\n- ExecIterateStreamAlg: adds to streams the ```iterate``` terminal operator.\r\n- ExecTakeStreamAlg: unifies terminal operators with the algebra with the ```take``` combinator.\r\n\r\n#### Factories\r\nThe following factories implement different combinations of behaviors:\r\n\r\n- ExecFusedPullFactory\r\n- ExecFutureFactory\r\n- ExecPullFactory\r\n- ExecPullWithIterateFactory\r\n- ExecPullWithTakeFactory\r\n- ExecPushFactory\r\n- ExecPushWithTakeFactory\r\n- LogFactory\r\n- PullFactory\r\n- PushFactory\r\n\r\n#### Higher Kinded types\r\nThe types that participate in higher-kinded polymorphism scenarios are: ```Future```, ```Id```, ```Pull``` and ```Push```.\r\n\r\n#### GADT encoding\r\nThe encoding appears in the ```gadt.evaluator``` package.\r\n\r\n#### Fluent APIs\r\nIn ```streamalg/fluent/Stream.cs``` and ```streamalg/fluent/Stream.scala``` we describe a\r\npossible solution of obtaining fluent APIs of Streams a la carte in C# and Scala.\r\n\r\n### Benchmarks\r\nThe ```run_benchmarks.sh``` script simply builds the JMH benchmarks über-jar and then uses the command line interface\r\nof JMH to pass the arguments of the experiments. The script will run all benchmarks in\r\n```streamalg/src/main/java/benchmarks/*``` and their description is included in the paper.\r\nThe user can run the benchmark script as is or by passing a regular-expression for filter to select only some of them. The\r\nmicro-benchmark suite can be passed the number of elements ```N``` for map, count, operations with large number of elements, ```N_small```\r\nthat is used for cart and limit/take examples. ```N_limit``` is used as the parameter for ```limit``` and ```F``` is used for\r\nbenchmarks with fused pipelines.\r\n\r\nFor more information on JMH the user can run it directly,\r\ne.g., to get the help dialog ```java -jar target/microbenchmarks.jar -h```.\r\n\r\nWe omitted baseline tests from the paper (although we included them in the repo) as the focus of the paper\r\nis not on comparing hand-optimized tight loops with streaming pipelines.\r\nWe have investigated this in previous work (http://arxiv.org/abs/1406.6631) and it is something that\r\nwe would like to investigate about the OpenJDK specifically in the immediate future.\r\n\r\nWe include three basic categories of benchmarks: _basic pipelines_ with various combinations about both Pull and Push algebras,\r\n_fused pipelines_ to exercise map and filter fusion and help with the comparison between the non-fused pipelines,\r\n_iterator pipelines_ to demonstrate differences of the Pull algebra and the obtaining of an iterator from Java 8 Streams\r\nand _take pipelines_ (the ```take``` operator is the same as the ```limit``` operator in Java 8 Streams.\r\n\r\n### Team\r\n\r\nAggelos Biboudis ([@biboudis](https://twitter.com/biboudis)), Nick Palladinos\r\n([@NickPalladinos](https://twitter.com/NickPalladinos)), George Fourtounis\r\n([@gf0ur](https://twitter.com/gf0ur)) and\r\n[Yannis Smaragdakis](http://www.di.uoa.gr/~smaragd/).\r\n","google":"UA-30141427-4","note":"Don't delete this file! It's used internally to help with page regeneration."}